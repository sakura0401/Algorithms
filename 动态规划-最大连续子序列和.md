### 最大连续子序列和
* 问题描述：
	* 设有一个含有 N 个整数的序列 A[1] ~ A[N]，求其所有**连续子序列**和的最大值，即求 A[i] + A[i+1] + ... + A[j] 的最大值，其中，1 ≤ i ≤ j ≤ N。
	* 如果用枚举求解该问题，则需要如下的三重循环:
	 
			int max_sub_seq = -INF; // INF为定义的无穷大
			for ( int i = 1; i <= N; ++i )    // i为子序列起点
			{
				for ( int j = i; j <= N; ++j )  // j为子序列终点
				{
					int sum = 0;
					for ( int k = i; k <= j; ++k )
						sum += A[k];
					if ( sum > max_sub_seq )
						max_sub_seq = sum;
				}
			}
			return  sum;

	* 以上简单枚举算法的复杂度 ~O(N^3)，算法效率较低。实际上该问题有效率为 O(N) 的算法。
		* 记序列 A[1], A[2], ..., A[n] 的最大连续子列和为 MS(n)，而**以 A[i] 结尾的**所有的连续子列中最大子列和为 ES(i)，显然有：①. MS(n) = max{ES(1), ES(2), ..., ES(n)}。如果有某种方法可以依次计算 ES(i), i = 1, 2, ..., n，则可由上式求得整个序列的最大连续子列和。
		* 设想数字是连续输入的。若已经输入了 m 个数字，而我们已知 ES(m)，那么当第 m+1 个数字输入后，如何由 ES(m) 求得 ES(m+1) 呢？显然有: ②. ES(m+1) = max{ES(m)+A[m+1], A[m+1]}。因为所有以 A[m+1] 结尾的连续子序列只有两种情况：包括 A[m] 和 不包括 A[m]，不包括 A[m] 的连续子列只有 A[m+1],而包括 A[m] 的所有连续子列去掉 A[m+1] 后必定是一个以 A[m] 结尾的连续子列。观察上式，计算新的 ES(m+1) 只需要 ES(m)，所以我们只要用一个变量保存最新的 ES 即可，然后计算时不断将最新的 ES 与 MS 比较，如果 ES > MS 则更新 MS 为 ES。
		* 基于核心的①、②两式，可以由如下算法：
		
				int maxSubSequence(int * a, int len)	// a的有效元素从a[1]开始
				{
					int ms = -INF;
					int es = 0;
					for ( int i = 1; i <= len; ++i )
					{
						/* 该if-else语句相当于 (2) 式 */	
						if ( es > 0 )
							es = es + a[i];
						else
							es = a[i];
						/* 更新最大连续子列和 */
						if ( ms < es )	// 根据 (1) 式
							ms = es;
					}
					return ms;
				}
		* 注意到以上算法将 ES(m+1) = max(ES(m)+A[m+1], A[m+1]) 等价为循环中的第一个 `if-else` 分支。这是因为当 ES(m) > 0 时，ES(m) + A[i+1] > A[i+1]，而若 ES(m) ≤ 0，则 ES(m) + A[m+1] ≤ A[m+1]。
